"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformanceAnalyzer = void 0;
const performance_result_1 = require("./entities/performance-result");
const calculator_1 = __importDefault(require("./helpers/calculator"));
const file_writer_1 = require("./helpers/file-writer");
const group_1 = __importDefault(require("./helpers/group"));
const objects_to_csv_1 = __importDefault(require("objects-to-csv"));
const variables_1 = require("./constants/variables");
const logger_1 = __importDefault(require("./helpers/logger"));
class PerformanceAnalyzer {
    constructor() {
        this._performanceResults = new Array();
    }
    async analyze(options, workerIndex) {
        const logger = new logger_1.default(options.suppressConsoleResults);
        let recentDaysMessage = '';
        const fileWriter = file_writer_1.FileWriter.getInstance();
        const resultsDir = global._playwrightPerformanceResultsDir;
        const logFilePath = fileWriter.getFilePath(resultsDir, variables_1.variables.logFileName);
        const saveDataFilePath = fileWriter.getFilePath(resultsDir, options.performanceResultsFileName);
        let performanceLogEntries = await this.deserializeData(logFilePath);
        let groupedResults;
        if (options.recentDays) {
            recentDaysMessage = `[Recent days:${options.recentDays}]`;
        }
        if (options.dropResultsFromFailedTest || options.recentDays) {
            const cutoffDate = Date.now() - ((options.recentDays || 0) * 24 * 60 * 60 * 1000);
            const filteredEntries = performanceLogEntries.filter((e) => {
                if (options.recentDays && e.startTime < cutoffDate) {
                    return false;
                }
                if (options.dropResultsFromFailedTest) {
                    return e.isTestPassed;
                }
                return true;
            });
            performanceLogEntries = filteredEntries;
        }
        if (!performanceLogEntries || performanceLogEntries.length == 0) {
            return;
        }
        groupedResults = !options.analyzeByBrowser ? group_1.default.groupBy(performanceLogEntries, p => [p.name]) : group_1.default.groupBy(performanceLogEntries, p => [p.name, p.brName]);
        groupedResults.forEach(group => {
            const durationList = group.map(t => t.duration);
            const performanceResult = new performance_result_1.PerformanceResult();
            const avgAndSte = calculator_1.default.getAverageAndStandardDeviation(durationList);
            performanceResult.name = group[0].name;
            performanceResult.brName = options.analyzeByBrowser ? group[0].brName : "general";
            performanceResult.earliestTime = group[0].startDisplayTime;
            performanceResult.latestTime = group[group.length - 1].startDisplayTime;
            performanceResult.avgTime = avgAndSte[0];
            performanceResult.sem = avgAndSte[1];
            performanceResult.repeats = durationList.length;
            performanceResult.minValue = Math.min(...durationList);
            performanceResult.maxValue = Math.max(...durationList);
            this._performanceResults.push(performanceResult);
        });
        const picked = this._performanceResults.map(({ name, brName, avgTime, sem, repeats, minValue, maxValue }) => ({ name, brName, avgTime, sem, repeats, minValue, maxValue }));
        logger.info(`\nPlaywright-performance results${recentDaysMessage}(worker[${workerIndex}]):\n`, false);
        logger.info(picked, false, true);
        await this.serializeData(saveDataFilePath);
        logger.info(`\nPlaywright-performance results saved to: ${saveDataFilePath}.csv/json\n`, true);
    }
    async serializeData(saveDataFilePath) {
        const fileWriter = file_writer_1.FileWriter.getInstance();
        await fileWriter.writeToFile(saveDataFilePath + ".json", JSON.stringify(this._performanceResults));
        const csv = new objects_to_csv_1.default(this._performanceResults);
        const csvString = await csv.toString(true);
        await fileWriter.writeToFile(saveDataFilePath + ".csv", csvString);
    }
    async deserializeData(fileName) {
        const fileWriter = file_writer_1.FileWriter.getInstance();
        const resultsArray = new Array();
        const textResultsArray = await fileWriter.readAllLines(fileName);
        textResultsArray.forEach(textResult => {
            if (textResult != "") {
                const performanceResult = JSON.parse(textResult);
                if (performanceResult.id !== undefined) {
                    resultsArray.push(performanceResult);
                }
            }
        });
        return resultsArray;
    }
}
exports.PerformanceAnalyzer = PerformanceAnalyzer;
